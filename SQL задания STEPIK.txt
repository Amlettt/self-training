раздел 1.2
	задание 6:

SELECT title,
	   author,
	   amount,
	   /*
	   ROUND(x,k) округляет значение x до k знаков полсе запятой,
	   если k не указано - x округляет до целого
	   */
	   ROUND ((price*0,7), 2) AS new_price,
FROM book;

	задание 7:
	При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, 
	на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на 10%, 
	а цену книг Есенина - на 5%. Написать запрос, куда включить автора, название книги и новую цену, 
	последний столбец назвать new_price. Значение округлить до двух знаков после запятой.
	
SELECT author,
	   title,
	   /*
	   ROUND(x,k) округляет значение x до k знаков полсе запятой,
	   если k не указано - x округляет до целого
	   */
	   ROUND ( IF(author = "Булгаков М.А.", price + price*0.1, IF(author = "Есенин С.А.", price + price*0.05, price)) , 2) AS new_price
FROM book;

	задание 8:
	Вывести автора, название  и цены тех книг, количество которых меньше 10.

SELECT author,
	   title,
	   price
FROM book
WHERE amount < 10;

	задание 8:
	Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600,
	а стоимость всех экземпляров этих книг больше или равна 5000.

SELECT title,
	   author,
	   price,
	   amount
FROM book
WHERE (price < 500 OR price > 600) AND amount*price >= 5000;

	задание 9:
	Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),
	а количество или 2, или 3, или 5, или 7 .

SELECT title,
	   author
FROM book
WHERE price BETWEEN 540.50 AND 800 AND amount IN (2, 3, 5, 7);

	задание 10:
	Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). 
	Информацию  отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).
	
SELECT author,
	   title
FROM book
WHERE amount BETWEEN 2 AND 14
ORDER BY 1 DESC, 2 ASC;

	задание 11:
	Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». 
	Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, 
	между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. 
	Информацию отсортировать по названию книги в алфавитном порядке.
	
SELECT title,
	   author
FROM book
WHERE title LIKE "_% _%" AND author LIKE "%С.%"
ORDER BY 1; 




раздел 1.3
	задание 1:
	Отобрать различные (уникальные) элементы столбца amount таблицы book.

SELECT *
FROM book
GROUP BY amount;

	задание 2:
	Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.
	Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.

SELECT author AS Автор,
	   COUNT(title) AS Различных_книг,
	   SUM(amount) AS Количество_экземпляров
FROM book
GROUP BY author;

	задание 3:
	Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . 
	Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно.

SELECT author,
	   MIN(price) AS Минимальная_цена,
	   MAX(price) AS Максимальная_цена,
	   AVG(price) AS Средняя_цена
FROM book
GROUP BY author;

	задание 4:
	Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), 
	а также вычислить налог на добавленную стоимость для полученных сумм (имя столбца НДС ),
	который включен в стоимость и составляет 18% (k=18),  а также стоимость книг  (Стоимость_без_НДС) без него. 
	Значения округлить до двух знаков после запятой. В запросе для расчета НДС(tax) и Стоимости без НДС(S_without_tax) использовать следующие формулы: -

SELECT author,
	   ROUND((SUM(price * amount)), 2) AS Стоимость,
	   ROUND((SUM(price * amount) * 0.18 / (1 + 0.18)), 2) AS НДС,
	   ROUND((SUM(price * amount) / (1 + 0.18)), 2) AS Стоимость_без_НДС
FROM book
GROUP BY author;

	задание 5:
	Вывести  цену самой дешевой книги, цену самой дорогой и среднюю цену уникальных книг на складе. 
	Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой.
	
SELECT MIN(price) AS Минимальная_цена,
	   MAX(price) AS Максимальная_цена,
	   ROUND((AVG(price)), 2) AS Средняя_цена
FROM book;
	
	задание 6:
	Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. 
	Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.
		
SELECT ROUND((AVG(price)), 2) AS Средняя_цена,
	   ROUND((SUM(price*amount)), 2) AS Стоимость
FROM book
WHERE amount BETWEEN 5 AND 14;

	задание 7:
	Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». 
	В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. 
	Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.
	
SELECT author,
       SUM(price*amount) AS Стоимость
FROM book
WHERE title NOT IN ("Идиот", "Белая гвардия")
GROUP BY author
HAVING SUM(price*amount) > 5000
ORDER BY 2 DESC;
	
	задание 8:
	Узнать сколько авторов, у которых есть книги со стоимостью более 500 и количеством более 1 шт на складе, 
	при количестве различных названий произведений не менее 2-х. Вывести автора, количество различных произведений автора, 
	минимальную цену и количество книг на складе.

SELECT author AS Автор,
       COUNT(title) AS Количество_произведений,
       MIN(price) AS Минимальная_стоимость,
       SUM(amount) AS Количество_книг_на_складе
FROM book
WHERE price >500 AND amount > 1
GROUP BY author
HAVING COUNT(title) >= 2;

	
	
	
раздел 1.4
	задание 1:
	Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. 
	Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.
	
SELECT author, 
       title, 
       price
FROM book
WHERE price <= (
         SELECT AVG(price) 
         FROM book
        )
ORDER BY 3 DESC;

	задание 2:
	Вывести информацию (автора, название и цену) о тех книгах, 
	цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде.
	
SELECT author, 
       title, 
       price
FROM book
WHERE price BETWEEN (
         SELECT MIN(price) 
         FROM book
        )
        AND
        ((
         SELECT MIN(price) 
         FROM book
        ) + 150)
ORDER BY 3;

	задание 3:
	Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется.
	
SELECT author, 
       title, 
       amount
FROM book
WHERE amount NOT IN (
    SELECT amount
    FROM book
    GROUP BY amount
    HAVING COUNT(title) > 1
    );
	
	задание 4:
	Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.
	

SELECT author, 
       title, 
       price
FROM book
WHERE price < ANY (
    SELECT MIN(price)
    FROM book
    GROUP BY author
    );

	задание 5:
	Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, 
	равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, 
	текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя Заказ. 
	В результат не включать книги, которые заказывать не нужно.

SELECT title, 
       author, 
       amount,
       (SELECT MAX(amount) FROM book) - amount AS Заказ
FROM book
WHERE amount < (
    SELECT MAX(amount)
    FROM book
    );
	
	задание 6:
	Два космонавта хотят взять с собой в полет по книжке. Чем книга дороже, тем она интереснее. Капитан возьмет самую дорогую, 
	какую книгу возьмет в полет помощник, если они договорились взять 2 самые интересные книги )))
	P.S. Все книги имеют разную цену.

SELECT author, 
       title
FROM book
WHERE price < (SELECT MAX(price) FROM book)
ORDER BY price DESC
LIMIT 1;
--- ТОПОВЫЙ ВАРИАНТ LIMIT 1,1 - указываем сначала сколько пропускаем элементов, а потом какое количество элементов нужено получить
SELECT * FROM book ORDER BY price DESC LIMIT 1,1;





раздел 1.5
	задание 1:
	Создать таблицу поставка (supply), которая имеет ту же структуру, что и таблиц book.

CREATE TABLE supply(
    supply_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8, 2),
    amount INT
    );
	
	задание 2:
	Занесите в таблицу supply четыре записи, чтобы получилась следующая таблица:

INSERT INTO supply(
    title, author, price, amount)
    VALUES 
    ("Лирика", "Пастернак Б.Л.", 518.99, 2),
    ("Черный человек", "Есенин С.А.", 570.20, 6),
    ("Белая гвардия", "Булгаков М.А.", 540.50, 7),
    ("Идиот", "Достоевский Ф.М.", 360.80, 3);

	задание 3:
	Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.
	
INSERT INTO book(title, author, price, amount)
    SELECT title, author, price, amount
    FROM supply
    WHERE author NOT IN ("Булгаков М.А.", "Достоевский Ф.М.");
	
	задание 4:
	Занести из таблицы supply в таблицу book только те книги, авторов которых нет в book.
	
INSERT INTO book(title, author, price, amount)
    SELECT title, author, price, amount
    FROM supply
    WHERE author NOT IN (
        SELECT author
        FROM book);
		
	задание 5:
	Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10, включая границы.
		
UPDATE book 
    SET price = 0.9 * price
    WHERE amount BETWEEN 5 AND 10;
		
	задание 6:
	В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, 
	указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%.
		
UPDATE book 
    SET buy = IF(buy > amount , amount , buy),
        price = IF(buy = 0, price * 0.9, price);
		
	задание 7:
	Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book 
	( увеличить их количество на значение столбца amountтаблицы supply), 
	но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).
		
UPDATE book, supply 
SET book.amount = book.amount + supply.amount,
    book.price = (book.price + supply.price) / 2
WHERE book.title = supply.title AND book.author = supply.author;

	задание 8:
	Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10.
	
DELETE FROM supply
       WHERE author IN (
           SELECT author
           FROM book
           GROUP BY author
           HAVING SUM(amount) > 10);
		   
	задание 9:
	Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, 
	количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. 
	В таблицу включить столбец amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.
	
CREATE TABLE ordering AS
    SELECT author, 
           title,
           (SELECT AVG(amount) FROM book) AS amount
    FROM book
    WHERE amount < (SELECT AVG(amount) FROM book);
	
	задание 10:
	Делаем скидку 5% на самое большое количество экземпляров книг (Стихи Есенина), чтобы поскорее расходились.
	
UPDATE book AS a1 SET a1.price = a1.price * 0.9
			WHERE a1.amount = (SELECT MAX(a2.amount) FROM (SELECT amount FROM book) AS a2);






раздел 1.6
	задание 1:
	Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», 
	в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last.

SELECT name, city, per_diem, date_first, date_last
    FROM trip
    WHERE name LIKE '%а _%'
    ORDER BY 4 DESC;
	
	задание 2:
	Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.
	
SELECT DISTINCT(name)
    FROM trip
    WHERE city = 'Москва'
    ORDER BY 1;
	
	задание 3:
	Для каждого города посчитать, сколько раз сотрудники в нем были.  
	Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество. 

SELECT city, COUNT(*) AS Количество
    FROM trip
    GROUP BY city
    ORDER BY 1;
	
	задание 4:
	Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество.
	
SELECT city, COUNT(*) AS Количество
    FROM trip
    GROUP BY city
    ORDER BY 2 DESC
    LIMIT 2;
	
	задание 5:
	Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  
	длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность.
	Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).
	
SELECT name, city, DATEDIFF(date_last, date_first) + 1 AS Длительность
    FROM trip
    WHERE city NOT IN ("Москва", "Санкт-Петербург")
    ORDER BY 3 DESC, 2 DESC;
	
	задание 6:
	Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. 
	В результат включить столбцы name, city, date_first, date_last.
	
SELECT name, city, date_first, date_last
    FROM trip
    WHERE DATEDIFF(date_last, date_first) = (
        SELECT MIN(DATEDIFF(date_last, date_first))
        FROM trip);
		
	задание 7:
	Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). 
	В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, 
	а затем по фамилии сотрудника.
	
SELECT name, city, date_first, date_last
    FROM trip
    WHERE MONTH(date_first) = MONTH(date_last)
    ORDER BY 2, 1;
	
	задание 8:
	Вывести название месяца и количество командировок для каждого месяца. 
	Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. 
	Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. 
	Название столбцов – Месяц и Количество.
	
SELECT MONTHNAME(date_first) AS Месяц, COUNT(*) AS Количество
    FROM trip
    GROUP BY MONTHNAME(date_first)
    ORDER BY 2 DESC, 1;
	
	задание 9:
	Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, 
	первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец per_diem.
	Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных. Последний столбец назвать Сумма. 
	Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.
	
SELECT name, city, date_first, (DATEDIFF(date_last, date_first) + 1) * per_diem AS Сумма
    FROM trip
    WHERE date_first BETWEEN '2020-02-01' AND '2020-03-31'
    ORDER BY 1, 4 DESC;
	
	задание 10:
	Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, 
	которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Последний столбец назвать Сумма.

SELECT name, SUM(per_diem*(DATEDIFF(date_last, date_first) + 1)) AS Сумма
    FROM trip
    GROUP BY name
    HAVING COUNT(*) > 3
    ORDER BY 2 DESC;
	
	



раздел 1.7
	задание 1:
	Создать таблицу fine следующей структуры:
	
CREATE TABLE fine(
    fine_id	INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(30),
    number_plate VARCHAR(6),
    violation VARCHAR(50),
    sum_fine FLOAT(8, 2),
    date_violation	DATE,
    date_payment DATE
    );
	
	задание 2:
	В таблицу fine первые 5 строк уже занесены. Добавить в таблицу записи с ключевыми значениями 6, 7, 8.
	 
INSERT INTO fine (name, number_plate, violation, sum_fine, date_violation, date_payment) 
    VALUES ("Баранов П.Е.",	"Р523ВТ", "Превышение скорости(от 40 до 60)", NULL, "2020-02-14",NULL),
        ("Абрамова К.А.", "О111АВ", "Проезд на запрещающий сигнал", NULL, "2020-02-23",NULL),
        ("Яковлев Г.Р.", "Т330ТТ", "Проезд на запрещающий сигнал", NULL, "2020-03-03",NULL);
		
	задание 3:
	Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation.
	При этом суммы заносить только в пустые поля столбца  sum_fine.

UPDATE fine AS a, traffic_violation AS b SET a.sum_fine = b.sum_fine 
    WHERE a.sum_fine IS NULL AND a.violation = b.violation;
	
	задание 4:
	Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило 
	два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, 
	сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.
	
SELECT name, number_plate, violation
    FROM fine
    GROUP BY name, number_plate, violation
    HAVING count(*) >= 2
    ORDER BY 1, 2, 3;
	
	задание 5:
	В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 
	
UPDATE fine AS a SET a.sum_fine = 2*a.sum_fine
    WHERE a.date_payment IS NULL AND (a.name, a.number_plate, a.violation) IN (SELECT b.name, b.number_plate, b.violation
    FROM (SELECT * FROM fine) AS b
    GROUP BY b.name, b.number_plate, b.violation
    HAVING count(*) >= 2);
	
	задание 6:
	Необходимо:
	В таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
	уменьшить начисленный штраф в таблице fine в два раза  (только для тех штрафов, информация о которых занесена в таблицу payment) , 
	если оплата произведена не позднее 20 дней со дня нарушения.

UPDATE fine f, payment p
SET f.date_payment = p.date_payment, f.sum_fine = IF (DATEDIFF(p.date_payment, p.date_violation) < 21, f.sum_fine / 2, f.sum_fine)
WHERE f.name = p.name AND f.number_plate = p.number_plate AND f.violation = p.violation AND f.date_violation = p.date_violation;

	задание 7:
	Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах 
	(Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

CREATE TABLE back_payment(
    name VARCHAR(30),
    number_plate VARCHAR(6),
    violation VARCHAR(50),
    sum_fine FLOAT(8, 2),
    date_violation	DATE
);

INSERT INTO back_payment(name, number_plate, violation, sum_fine, date_violation) 
			SELECT name, number_plate, violation, sum_fine, date_violation FROM fine WHERE date_payment IS NULL;
			
	задание 8:
	Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 
	
DELETE FROM fine WHERE date_violation < "2020-02-01";



--------
2 Раздел
	Задание 1:
	Создать таблицу author следующей структуры:
	
CREATE TABLE author (
    author_id INT PRIMARY KEY AUTO_INCREMENT,
    name_author	VARCHAR(50));
	
	 Задание 2:
	 Заполнить таблицу author. В нее включить следующих авторов:
	 
INSERT INTO author(name_author) VALUES("Булгаков М.А."),
                ("Достоевский Ф.М."),
                ("Есенин С.А."),
                ("Пастернак Б.Л.");
	
	Задание 3:
	Перепишите запрос на создание таблицы book , чтобы ее структура соответствовала структуре, показанной на логической схеме 
	(таблица genre уже создана, порядок следования столбцов - как на логической схеме в таблице book, genre_id  - внешний ключ) . 
	Для genre_id ограничение о недопустимости пустых значений не задавать. В качестве главной таблицы для описания поля  genre_id
	использовать таблицу genre следующей структуры:
	
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    genre_id INT,
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (genre_id) REFERENCES genre (genre_id),
    FOREIGN KEY (author_id) REFERENCES author (author_id) 
);

	Задание 4:
	Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, 
	должны удаляться все записи о книгах из таблицы book, написанные этим автором. 
	А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id. 

CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    genre_id INT,
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL,
    FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE
);

	Задание 5:
	Добавьте три последние записи (с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены:
	
INSERT INTO book (title, author_id, genre_id, price, amount) 
           VALUES("Стихотворения и поэмы", 3, 2, 650.00, 15),
                 ("Черный человек", 3, 2, 570.20, 6),
                 ("Лирика",	4, 2, 518.99, 2);
				 



Раздел 2.2

	Задание 1:
	Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.
	
SELECT a.title, b.name_genre, a.price
FROM 
    book AS a INNER JOIN genre AS b
    ON a.genre_id = b.genre_id
    WHERE a.amount > 8
    ORDER BY a.price DESC;
	
	Задание 2:
	Вывести все жанры, которые не представлены в книгах на складе.
	
SELECT a.name_genre
FROM genre AS a LEFT JOIN book AS b
     ON a.genre_id = b.genre_id
     WHERE b.title is NULL;   
	 
	Задание 3:
	Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. 
	Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, 
	отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.
	
SELECT a.name_city, b.name_author, DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND() * 365) DAY) AS Дата
    FROM city AS a CROSS JOIN author AS b
    ORDER BY 1, 3 DESC; 
	
	Задание 4:
	Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.
	
SELECT a.name_genre, b.title, c.name_author
FROM
    genre AS a 
    INNER JOIN book AS b ON a.genre_id = b.genre_id
    INNER JOIN author AS c ON b.author_id = c.author_id
WHERE a.name_genre like '%Роман%'
ORDER BY b.title;

	Задание 5:
	Посчитать количество экземпляров  книг каждого автора из таблицы author.  Вывести тех авторов,  количество книг которых меньше 10, 
	в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.
	
 SELECT a.name_author, SUM(b.amount) AS Количество
    FROM author AS a
    LEFT JOIN book AS b ON a.author_id = b.author_id
    GROUP BY a.name_author
    HAVING Количество < 10 OR Количество is NULL
    ORDER BY 2;
	
	Задание 6:
	Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные,
	что у каждого автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу book. 
	Пусть у нас  книга Есенина «Черный человек» относится к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (
	эти изменения в таблицы уже внесены).
	
SELECT DISTINCT(a.name_author)
    FROM author AS a
    INNER JOIN book AS b ON a.author_id = b.author_id
    WHERE a.author_id in (SELECT author_id 
                         FROM book
                         GROUP BY author_id
                         HAVING COUNT(DISTINCT genre_id) = 1)
                         
    ORDER BY 1;
	
	Задание 7:
	Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество экземпляров книги),
	написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде. Самым популярным считать жанр, 
	общее количество экземпляров книг которого на складе максимально.
	
SELECT b.title, c.name_author, a.name_genre, b.price, b.amount
FROM genre AS a
INNER JOIN book AS b ON a.genre_id = b.genre_id
INNER JOIN author AS c ON b.author_id = c.author_id
WHERE b.genre_id in (SELECT genre_id
                    FROM book
                    GROUP BY genre_id
                    HAVING SUM(amount) = (SELECT SUM(amount)FROM book
                    GROUP BY genre_id ORDER BY SUM(amount) DESC LIMIT 1))

ORDER BY 1;

	Задание 8:
	Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, 
	а также посчитать общее количество экземпляров книг в таблицах supply и book, столбцы назвать Название, Автор  и Количество.
	
SELECT book.title AS Название, author.name_author AS Автор, (book.amount + supply.amount) AS Количество
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author
    WHERE book.price = supply.price;

	Задание 9:
	Для каждого автора из таблицы author вывести количество книг, написанных им в каждом жанре.
	Вывод: ФИО автора, жанр, количество. Отсортировать по фамилии, затем - по убыванию количества написанных книг.

SELECT author.name_author, genre.name_genre, COUNT(book.title) AS Количество
    FROM author CROSS JOIN genre
	LEFT JOIN book ON book.author_id = author.author_id AND book.genre_id = genre.genre_id
	GROUP BY author.name_author, genre.name_genre

    ORDER BY 1, 3 DESC;





Раздел 2.3

	Задание 1:
	Для книг, которые уже есть на складе (в таблице book), но по другой цене, чем в поставке (supply),  
	необходимо в таблице book увеличить количество на значение, указанное в поставке,  и пересчитать цену. 
	А в таблице  supply обнулить количество этих книг. 

UPDATE book
    INNER JOIN author ON book.author_id = author.author_id
    INNER JOIN supply ON book.title = supply.title AND author.name_author = supply.author
    SET book.amount = book.amount + supply.amount,
        book.price = (book.price*book.amount + supply.price*supply.amount)/(book.amount + supply.amount),
        supply.amount = 0
    WHERE book.price <> supply.price;
	
	Задание 2:
	Включить новых авторов в таблицу author с помощью запроса на добавление, а затем вывести все данные из таблицы author.  
	Новыми считаются авторы, которые есть в таблице supply, но нет в таблице author.
	
INSERT author (name_author) SELECT supply.author FROM author 
                                                 RIGHT JOIN supply ON author.name_author = supply.author
                                                 WHERE author.name_author IS NULL;
                                                
SELECT * FROM author;

	Задание 3:
	Добавить новые книги из таблицы supply в таблицу book на основе сформированного выше запроса. Затем вывести для просмотра таблицу book.
	
INSERT book (title, author_id, price, amount) SELECT supply.title, 
                                                     author.author_id, 
                                                     supply.price,
                                                     supply.amount
                                              FROM supply
                                              INNER JOIN author ON author.name_author = supply.author
                                              WHERE supply.amount <> 0;

SELECT * FROM book;

	Задание 4:
	Занести для книги «Стихотворения и поэмы» Лермонтова жанр «Поэзия», а для книги «Остров сокровищ» Стивенсона - «Приключения».
	(Использовать два запроса).
	
UPDATE book set genre_id = (SELECT genre.genre_id FROM genre WHERE genre.name_genre = 'Поэзия') 
	WHERE title = 'Стихотворения и поэмы' AND author_id = (SELECT author.author_id FROM author WHERE author.name_author LIKE 'Лермонтов%');
UPDATE book set genre_id = (SELECT genre.genre_id FROM genre 
	WHERE genre.name_genre = 'Приключения') WHERE title = 'Остров сокровищ' AND author_id = (SELECT author.author_id FROM author WHERE author.name_author LIKE 'Стивенсон%');
	
	Задание 5:
	Удалить всех авторов и все их книги, общее количество книг которых меньше 20.

DELETE FROM author WHERE author_id in (SELECT book.author_id FROM book GROUP BY author_id HAVING SUM(amount) < 20);

	Задание 6:
	Удалить все жанры, к которым относится меньше 4-х наименований книг. В таблице book для этих жанров установить значение Null.
	
DELETE FROM genre WHERE genre_id in (SELECT book.genre_id FROM book GROUP BY book.genre_id HAVING COUNT(book.title) < 4);

	Задание 7:
	далить всех авторов, которые пишут в жанре "Поэзия". Из таблицы book удалить все книги этих авторов. 
	В запросе для отбора авторов использовать полное название жанра, а не его id
	
DELETE FROM author USING author
                    INNER JOIN book ON book.author_id = author.author_id
                    INNER JOIN genre ON book.genre_id = genre.genre_id
                    WHERE genre.name_genre = 'Поэзия';
					
	Задание 9:
	Добавим книги, которых нет в book, из supply. Для этого сначала добавим авторов в author, затем книги, затем вручную укажем жанр новым книгам.

	Изменим цену книг в book, заменив ее на среднюю цену книг того же жанра. То есть в основном запросе на изменение цены UPDATE book SET... 
	мы пишем подзапрос, который считает среднюю цену книг каждого жанра (AVG(price), GROUP BY genre_id) и обновляет цену в зависимости от того, 
	к какому жанру принадлежит конкретная книга.
	
INSERT author (name_author) SELECT supply.author FROM supply WHERE supply.author NOT IN (SELECT author.name_author FROM author);
INSERT book (title, author_id, price, amount) SELECT supply.title, author.author_id, supply.price, supply.amount FROM supply INNER JOIN author ON supply.author = author.name_author WHERE supply.title NOT IN (SELECT book.title FROM book);
SELECT * FROM book;
UPDATE book SET genre_id = 1 WHERE genre_id is NULL AND title = 'Доктор Живаго';
UPDATE book SET genre_id = 3 WHERE genre_id is NULL AND title = 'Остров сокровищ';
UPDATE book SET price = (SELECT AVG(A.price) FROM (SELECT * FROM book) AS A GROUP BY A.genre_id HAVING A.genre_id = book.genre_id);
SELECT * FROM book;





Раздел 2.4

	Задание 1:
	Вывести все заказы Баранова Павла (id заказа, какие книги, по какой цене и в каком количестве он заказал) 
	в отсортированном по номеру заказа и названиям книг виде.

SELECT buy.buy_id, title, price, buy_book.amount
FROM 
    client 
    INNER JOIN buy ON client.client_id = buy.client_id
    INNER JOIN buy_book ON buy_book.buy_id = buy.buy_id
    INNER JOIN book ON buy_book.book_id=book.book_id
WHERE name_client = 'Баранов Павел'
ORDER BY 1, 2;

	Задание 2:
	Посчитать, сколько раз была заказана каждая книга, для книги вывести ее автора (нужно посчитать, в каком количестве заказов фигурирует каждая книга). 
	Вывести фамилию и инициалы автора, название книги, последний столбец назвать Количество. 
	Результат отсортировать сначала  по фамилиям авторов, а потом по названиям книг.
	
SELECT name_author, title, COUNT(buy_book.amount) AS Количество
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    LEFT JOIN buy_book ON book.book_id = buy_book.book_id
    GROUP BY author.name_author, book.title
ORDER BY 1, 2;

	Задание 3:
	Вывести города, в которых живут клиенты, оформлявшие заказы в интернет-магазине. Указать количество заказов в каждый город, 
	этот столбец назвать Количество. Информацию вывести по убыванию количества заказов, а затем в алфавитном порядке по названию городов.
	
SELECT name_city, COUNT(buy.buy_id) AS Количество
FROM city
    INNER JOIN client ON client.city_id = city.city_id
    INNER JOIN buy ON buy.client_id = client.client_id
    GROUP BY name_city

ORDER BY 2 DESC, 1;

	Задание 4:
	Вывести номера всех оплаченных заказов и даты, когда они были оплачены.
	
SELECT buy_step.buy_id, buy_step.date_step_end
FROM step
    INNER JOIN buy_step ON buy_step.step_id = step.step_id
    WHERE step.name_step = 'Оплата' AND buy_step.date_step_end IS NOT NULL;
	
	Задание 5:
	Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость 
	(сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде. Последний столбец назвать Стоимость.
	
SELECT buy.buy_id, client.name_client, SUM(buy_book.amount * book.price) AS Стоимость
FROM client
    INNER JOIN buy ON buy.client_id = client.client_id
    INNER JOIN buy_book ON buy_book.buy_id = buy.buy_id
    INNER JOIN book ON book.book_id = buy_book.book_id
    GROUP BY buy.buy_id
    

ORDER BY 1;

	Задание 6:
	Вывести номера заказов (buy_id) и названия этапов, на которых они в данный момент находятся. 
	Если заказ доставлен –  информацию о нем не выводить. Информацию отсортировать по возрастанию buy_id.
	
SELECT buy_step.buy_id, step.name_step
FROM step
INNER JOIN buy_step ON buy_step.step_id = step.step_id
WHERE buy_step.date_step_beg IS NOT NULL AND buy_step.date_step_end IS NULL
ORDER BY 1;

	Задание 7:
	В таблице city для каждого города указано количество дней, за которые заказ может быть доставлен в этот город 
	(рассматривается только этап Транспортировка). Для тех заказов, которые прошли этап транспортировки, 
	вывести количество дней за которое заказ реально доставлен в город. А также, если заказ доставлен с опозданием, указать количество дней задержки, 
	в противном случае вывести 0. В результат включить номер заказа (buy_id), а также вычисляемые столбцы Количество_дней и Опоздание. 
	Информацию вывести в отсортированном по номеру заказа виде.\
	
SELECT buy_step.buy_id, 
    DATEDIFF(buy_step.date_step_end, buy_step.date_step_beg) AS Количество_дней, 
    IF(DATEDIFF(buy_step.date_step_end,buy_step.date_step_beg) > city.days_delivery, DATEDIFF(buy_step.date_step_end, buy_step.date_step_beg) - city.days_delivery, 0) AS Опоздание
FROM city
INNER JOIN client ON client.city_id = city.city_id
INNER JOIN buy ON buy.client_id = client.client_id
INNER JOIN buy_step ON buy_step.buy_id = buy.buy_id
WHERE buy_step.step_id = (SELECT step_id FROM step WHERE name_step = 'Транспортировка') AND buy_step.date_step_end IS NOT NULL
ORDER BY 1;

	Задание 8:
	Выбрать всех клиентов, которые заказывали книги Достоевского, информацию вывести в отсортированном по алфавиту виде.
	В решении используйте фамилию автора, а не его id.

SELECT client.name_client
FROM (select * FROM author WHERE name_author = 'Достоевский Ф.М.') AS A
INNER JOIN book ON book.author_id = A.author_id
INNER JOIN buy_book ON buy_book.book_id = book.book_id
INNER JOIN buy ON buy.buy_id = buy_book.buy_id
INNER JOIN client ON client.client_id = buy.client_id
GROUP BY client.client_id
ORDER BY 1;

	Задание 9:
	Вывести жанр (или жанры), в котором было заказано больше всего экземпляров книг, указать это количество. Последний столбец назвать Количество.

SELECT a.name AS name_genre, SUM(a.calc) AS Количество
FROM (SELECT genre.name_genre AS genr, buy_book.amount AS calc, genre.name_genre AS name
    FROM buy_book
        INNER JOIN book ON buy_book.book_id = book.book_id
        INNER JOIN genre ON book.genre_id = genre.genre_id) AS a
    GROUP BY genr
    HAVING SUM(a.calc) = (SELECT MAX(c.calc2) FROM (SELECT SUM(a.calc) AS calc2
FROM (SELECT genre.name_genre AS genr, buy_book.amount AS calc, genre.name_genre AS name
    FROM buy_book
        INNER JOIN book ON buy_book.book_id = book.book_id
        INNER JOIN genre ON book.genre_id = genre.genre_id) AS a
    GROUP BY genr) AS c)
	
	Задание 10:
	Сравнить ежемесячную выручку от продажи книг за текущий и предыдущий годы. Для этого вывести год, месяц, 
	сумму выручки в отсортированном сначала по возрастанию месяцев, затем по возрастанию лет виде. Название столбцов: Год, Месяц, Сумма
	
SELECT YEAR(date_payment) AS Год, MONTHNAME(date_payment) AS Месяц, SUM(amount*price) AS Сумма
FROM 
    buy_archive
    GROUP BY MONTHNAME(date_payment), YEAR(date_payment)
UNION ALL
SELECT YEAR(date_step_end), MONTHNAME(date_step_end), SUM(buy_book.amount*price)
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"
GROUP BY MONTHNAME(date_step_end), YEAR(date_step_end)
ORDER BY 2, 1; 

	Задание 11:
	Для каждой отдельной книги необходимо вывести информацию о количестве проданных экземпляров и их стоимости за 2020 и 2019 год .
	Вычисляемые столбцы назвать Количество и Сумма. Информацию отсортировать по убыванию стоимости.
	
SELECT book.title, SUM(a.b)  AS Количество, SUM(a.c) AS Сумма
FROM (SELECT book_id, SUM(amount) AS b, SUM(amount*price) AS c
FROM 
    buy_archive
	WHERE YEAR(date_payment) IN ('2019')
    GROUP BY book_id
UNION ALL
SELECT buy_book.book_id, SUM(buy_book.amount), SUM(buy_book.amount*price)
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE date_step_end IS NOT Null and name_step = "Оплата" AND YEAR(date_step_end) IN ('2020')
GROUP BY book_id) AS a
INNER JOIN book ON book.book_id = a.book_id
GROUP BY a.book_id  
ORDER BY 3 DESC;

	Задание 12:
	Вывести названия книг, которые ни разу не были заказаны, отсортировав в алфавитном порядке.
	
SELECT title
FROM book
LEFT JOIN buy_book USING(book_id)
WHERE buy_book.book_id IS NULL
ORDER BY 1;





Раздел 2.5

	Задание 1:
	Включить нового человека в таблицу с клиентами. Его имя Попов Илья, его email popov@test, проживает он в Москве.
	
INSERT INTO client(name_client, city_id,email) VALUES ('Попов Илья', (SELECT city_id FROM city WHERE name_city = 'Москва'), 'popov@test');

	Задание 2:
	Создать новый заказ для Попова Ильи. Его комментарий для заказа: «Связаться со мной по вопросу доставки».
	
INSERT INTO buy(buy_description, client_id) SELECT 'Связаться со мной по вопросу доставки' AS a, client_id FROM client WHERE name_client = 'Попов Илья';

	Задание 3:
	В таблицу buy_book добавить заказ с номером 5. Этот заказ должен содержать книгу Пастернака «Лирика» в количестве 
	двух экземпляров и книгу Булгакова «Белая гвардия» в одном экземпляре.
	
INSERT INTO buy_book(buy_id, book_id, amount) SELECT 5 as a, book_id, 2 as b FROM author INNER JOIN book USING(author_id) WHERE name_author like '%Пастернак%' AND title like '%Лирика%';
INSERT INTO buy_book(buy_id, book_id, amount) SELECT 5 as a, book_id, 1 as b FROM author INNER JOIN book USING(author_id) WHERE name_author like '%Булгаков%' AND title like '%Белая гвардия%';

	Задание 4:
	Уменьшить количество тех книг на складе, которые были включены в заказ с номером 5 на то количество, которое в заказе с номером 5  указано.
	
UPDATE book,buy_book SET book.amount = book.amount - buy_book.amount
WHERE book.book_id = buy_book.book_id AND buy_book.buy_id = 5

	Задание 5:
	Создать счет (таблицу buy_pay) на оплату заказа с номером 5, в который включить название книг, их автора, цену,
	количество заказанных книг и  стоимость. Последний столбец назвать Стоимость. Информацию в таблицу занести в отсортированном по названиям книг виде.
	
CREATE TABLE buy_pay AS
            SELECT title, name_author, price, buy_book.amount, (price*buy_book.amount) AS Стоимость 
            FROM author 
            INNER JOIN book USING(author_id)
            INNER JOIN buy_book USING(book_id)
            WHERE buy_id = 5
            ORDER BY 1;
            
SELECT * FROM buy_pay;

	Задание 6:
	Создать общий счет (таблицу buy_pay) на оплату заказа с номером 5. Куда включить номер заказа, 
	количество книг в заказе (название столбца Количество) и его общую стоимость (название столбца Итого).  Для решения используйте ОДИН запрос.

CREATE TABLE buy_pay AS
            SELECT buy_id, SUM(buy_book.amount) AS Количество, SUM(price*buy_book.amount) AS Итого 
            FROM book
            INNER JOIN buy_book USING(book_id)
            WHERE buy_id = 5;
       
SELECT * FROM buy_pay;

	Задание 7:
	В таблицу buy_step для заказа с номером 5 включить все этапы из таблицы step, которые должен пройти этот заказ. 
	В столбцы date_step_beg и date_step_end всех записей занести Null.
	
INSERT INTO buy_step(buy_id, step_id, date_step_beg, date_step_end) SELECT buy_id, step_id, NULL, NULL FROM buy CROSS JOIN step WHERE buy_id = 5;

	Задание 8:
	В таблицу buy_step занести дату 12.04.2020 выставления счета на оплату заказа с номером 5.

UPDATE buy_step set date_step_beg = '2020-04-12' WHERE buy_id = 5 AND step_id = (SELECT step_id FROM step WHERE name_step = 'Оплата');

	Задание 9:
	Завершить этап «Оплата» для заказа с номером 5, вставив в столбец date_step_end дату 13.04.2020, и начать следующий этап («Упаковка»),
	задав в столбце date_step_beg для этого этапа ту же дату.
	
UPDATE buy_step SET date_step_end = '2020-04-13' WHERE buy_id = 5 AND step_id = (SELECT step_id FROM step WHERE name_step = 'Оплата');
UPDATE buy_step SET date_step_beg = '2020-04-13' WHERE buy_id = 5 AND step_id = 1 + (SELECT step_id FROM step WHERE name_step = 'Оплата');
SELECT * FROM buy_step WHERE buy_id = 5;

	Задание 10:
	Вывести количество заказов, находящихся в каждом из статусов.
	
SELECT name_step, SUM(IF(date_step_beg IS NOT NULL AND date_step_end IS NULL, 1, 0)) AS Количество_заказов
FROM step
LEFT JOIN buy_step USING(step_id)
GROUP BY name_step
ORDER BY 1;

SELECT * FROM buy_step;





Раздел 3.1

	Задание 1:
	Вывести студентов, которые сдавали дисциплину «Основы баз данных», указать дату попытки и результат. 
	Информацию вывести по убыванию результатов тестирования.
	
	
SELECT name_student, date_attempt, result
FROM subject
INNER JOIN attempt USING(subject_id)
INNER JOIN student USING(student_id)
WHERE name_subject = 'Основы баз данных'
ORDER BY 3 DESC;

	Задание 2:
	Вывести, сколько попыток сделали студенты по каждой дисциплине, а также средний результат попыток, 
	который округлить до 2 знаков после запятой. Под результатом попытки понимается процент правильных ответов на вопросы теста, 
	который занесен в столбец result.  В результат включить название дисциплины, а также вычисляемые столбцы Количество и Среднее. 
	Информацию вывести по убыванию средних результатов.
	
SELECT name_subject, COUNT(date_attempt) AS Количество, ROUND(AVG(result),2) AS Среднее
FROM subject
LEFT JOIN attempt USING(subject_id)
GROUP BY subject.subject_id
ORDER BY 3 DESC;

	Задание 3:
	Вывести студентов (различных студентов), имеющих максимальные результаты попыток. Информацию отсортировать в алфавитном порядке по фамилии студента.
	
SELECT name_student, result
FROM student
INNER JOIN attempt USING(student_id)
WHERE result = (SELECT MAX(A.result) FROM attempt as A)
ORDER BY 1;

	Задание 4:
	Если студент совершал несколько попыток по одной и той же дисциплине, то вывести разницу в днях между первой и последней попыткой. 
	В результат включить фамилию и имя студента, название дисциплины и вычисляемый столбец Интервал. Информацию вывести по возрастанию разницы. 
	Студентов, сделавших одну попытку по дисциплине, не учитывать. 
	
SELECT name_student, name_subject, DATEDIFF(MAX(date_attempt),MIN(date_attempt)) AS Интервал
FROM subject
INNER JOIN attempt USING(subject_id)
INNER JOIN student USING(student_id)
GROUP BY attempt.student_id, attempt.subject_id
HAVING COUNT(result) > 1
ORDER BY 3;

	Задание 5:
	Студенты могут тестироваться по одной или нескольким дисциплинам (не обязательно по всем).
	Вывести дисциплину и количество уникальных студентов (столбец назвать Количество), которые по ней проходили тестирование .
	Информацию отсортировать сначала по убыванию количества, а потом по названию дисциплины. В результат включить и дисциплины, 
	тестирование по которым студенты еще не проходили, в этом случае указать количество студентов 0.
	
SELECT name_subject, COUNT(DISTINCT(student_id)) AS Количество
FROM subject
LEFT JOIN attempt USING(subject_id)
GROUP BY subject.subject_id
ORDER BY 2 DESC, 1;
	
	Задание 6:
	Случайным образом отберите 3 вопроса по дисциплине «Основы баз данных». В результат включите столбцы question_id и name_question.
	
SELECT question_id, name_question
FROM subject
INNER JOIN question USING(subject_id)
WHERE name_subject = 'Основы баз данных'
ORDER BY RAND()
LIMIT 3;

	Задание 7:
	Вывести вопросы, которые были включены в тест для Семенова Ивана по дисциплине «Основы SQL» 2020-05-17  
	значение attempt_id для этой попытки равно 7). Указать, какой ответ дал студент и правильный он или нет (вывести Верно или Неверно). 
	В результат включить вопрос, ответ и вычисляемый столбец  Результат.
	
SELECT name_question, name_answer, IF(is_correct = 0, 'Неверно', 'Верно') AS Результат
FROM answer
INNER JOIN testing USING(answer_id)
INNER JOIN question ON question.question_id = testing.question_id
WHERE attempt_id = 7;
	
	Задание 8:
	Посчитать результаты тестирования. Результат попытки вычислить как количество правильных ответов, деленное на 3 
	(количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до двух знаков после запятой. 
	Вывести фамилию студента, название предмета, дату и результат. Последний столбец назвать Результат. 
	Информацию отсортировать сначала по фамилии студента, потом по убыванию даты попытки.
	
SELECT name_student, name_subject, date_attempt, ROUND((SELECT COUNT(*) 
FROM testing
INNER JOIN answer ON answer.answer_id = testing.answer_id 
WHERE attempt_id = C.attempt_id AND is_correct = 1) / 3 * 100, 2) AS Результат
FROM subject
INNER JOIN attempt USING(subject_id)
INNER JOIN student USING(student_id)
INNER JOIN testing AS C USING(attempt_id)

GROUP BY C.attempt_id

ORDER BY 1, 3 DESC;
	
	Задание 9:
	Для каждого вопроса вывести процент успешных решений, то есть отношение количества верных ответов к общему количеству ответов, 
	значение округлить до 2-х знаков после запятой. Также вывести название предмета, к которому относится вопрос, 
	и общее количество ответов на этот вопрос. В результат включить название дисциплины, вопросы по ней (столбец назвать Вопрос), 
	а также два вычисляемых столбца Всего_ответов и Успешность. Информацию отсортировать сначала по названию дисциплины, потом по убыванию успешности, 
	а потом по тексту вопроса в алфавитном порядке.
	
SELECT name_subject, CONCAT(SUBSTRING(name_question, 1,30),'...') AS Вопрос, COUNT(*) AS Всего_ответов, ROUND((SELECT COUNT(*) 
FROM testing
INNER JOIN answer ON answer.answer_id = testing.answer_id 
WHERE testing.question_id = C.question_id AND is_correct = 1) / COUNT(*) * 100, 2) AS Успешность
FROM subject
INNER JOIN question ON subject.subject_id = question.subject_id
INNER JOIN testing AS C USING(question_id)
INNER JOIN attempt USING(attempt_id)


GROUP BY C.question_id

ORDER BY 1, 4 DESC, 2;	
	
	Задание 10:
	Сделать шпаргалку по всем предметам (для которых в базе есть вопросы
	
SELECT name_subject, LEFT(name_question,30), LEFT(name_answer,30)
FROM subject
INNER JOIN question USING(subject_id)
INNER JOIN answer USING(question_id)
WHERE is_correct IS true	
	




Раздел 3.2

	Задание 1:
	В таблицу attempt включить новую попытку для студента Баранова Павла по дисциплине «Основы баз данных». 
	Установить текущую дату в качестве даты выполнения попытки.
	
INSERT INTO attempt(student_id, subject_id, date_attempt) VALUES(
				(SELECT student_id FROM student WHERE name_student = "Баранов Павел"), 
				(SELECT subject_id FROM subject WHERE name_subject = "Основы баз данных"), 
				NOW());  
				
	Задание 2:
	Случайным образом выбрать три вопроса (запрос) по дисциплине, тестирование по которой собирается проходить студент, 
	занесенный в таблицу attempt последним, и добавить их в таблицу testing. 
	id последней попытки получить как максимальное значение id из таблицы attempt.

INSERT INTO testing (attempt_id, question_id)
Select  attempt_id,question_id
FROM attempt 
INNER JOIN question USING(subject_id)
WHERE attempt_id=(SELECT max(attempt_id) from attempt)
ORDER BY RAND ()
LIMIT 3
;
	
	Задание 3:
	Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат(запрос) 
	и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных ответов, 
	деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.

	Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 8.
	
UPDATE attempt SET result = (SELECT CEILING(SUM(is_correct)/3*100) FROM answer
INNER JOIN testing USING(answer_id)
WHERE attempt_id = 8) WHERE attempt_id = 8;

	Задание 4:
	далить из таблицы attempt все попытки, выполненные раньше 1 мая 2020 года. Также удалить и все соответствующие этим попыткам вопросы 
	из таблицы testing, которая создавалась следующим запросом:
	CREATE TABLE testing (
    testing_id INT PRIMARY KEY AUTO_INCREMENT, 
    attempt_id INT, 
    question_id INT, 
    answer_id INT,
    FOREIGN KEY (attempt_id)  REFERENCES attempt (attempt_id) ON DELETE CASCADE);
	
DELETE FROM attempt WHERE date_attempt < '2020-05-01';

	Задание 5:
	В институте счастливое событие - студенческая свадьба! Баранов Павел и Яковлева Галина решили соединить себя узами брака и жить дальше вместе долго и счастливо. На первом семейном совете, после долгих криков и оскорблений, было принято два важных решения:
	1. Галина берёт фамилию мужа.
	2. Так как они теперь семья и у них должно быть всё поровну, то и результаты всех попыток тестирования у них тоже должны быть одинаковые.
	Таким образом, ваша задача:
	1. Первым запросом изменить в базе фамилию Галины.
	2. Вторым запросом изменить результаты тестирования в таблице attempt для членов новой семьи, выставив им за каждую попытку средний результат всех их попыток вместе взятых.

SELECT * FROM student;
UPDATE student set name_student = 'Баранова Галина' WHERE name_student = 'Яковлева Галина';
SELECT * FROM student;
SELECT * FROM attempt;

UPDATE attempt set result = (SELECT* FROM(SELECT CEILING(AVG(result)) FROM attempt INNER JOIN student USING(student_id) WHERE name_student like 'Баранов%') AS n)
WHERE student_id in (SELECT* FROM(SELECT student_id FROM student WHERE name_student like 'Баранов%') AS v);

SELECT * FROM attempt;




Раздел 3.2

	Задание 1:
	Вывести абитуриентов, которые хотят поступать на образовательную программу «Мехатроника и робототехника» в отсортированном по фамилиям виде.
	
SELECT name_enrollee FROM enrollee
INNER JOIN program_enrollee USING(enrollee_id)
INNER JOIN program USING(program_id)
WHERE name_program = "Мехатроника и робототехника"
ORDER BY 1;

	Задание 2:
	Вывести образовательные программы, на которые для поступления необходим предмет «Информатика». Программы отсортировать в обратном алфавитном порядке.
	
SELECT name_program FROM program
INNER JOIN program_subject USING(program_id)
INNER JOIN subject USING(subject_id)
WHERE name_subject = "Информатика"
ORDER BY 1 DESC;

	Задание 3:
	Выведите количество абитуриентов, сдавших ЕГЭ по каждому предмету, максимальное, минимальное и среднее значение баллов по предмету ЕГЭ. 
	Вычисляемые столбцы назвать Количество, Максимум, Минимум, Среднее. Информацию отсортировать по названию предмета в алфавитном порядке, 
	среднее значение округлить до одного знака после запятой.
	
SELECT name_subject, COUNT(result) AS Количество, MAX(result) AS Максимум, MIN(result) AS Минимум, ROUND(AVG(result), 1) AS Среднее
FROM subject
INNER JOIN enrollee_subject USING(subject_id)
GROUP BY name_subject 
ORDER BY 1;
